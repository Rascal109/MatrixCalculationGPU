# MatrixCalculationGPU
## 注意
* Vulkanがいじりたくて、かつ普段使っているGPU内蔵CPUのノートPCで並列演算がしてみたくて作ってみたものである。
* Vulkanの設定が必要。
* ワークグループのサイズや共有メモリの大きさなど、PC依存の要素がややあるので、その都度パラメータをいじる必要があるかも？
* `matCalculation.cpp`における`shaderModule`の作成で、`.spv`ファイルのパスを入れているが、初期状態はsrcフォルダの中としている。Visual Studio2022においては、
slnファイルに対してどこにあるかというパスを通せばよいみたい。
* シェーダの変更がしたかったら、`.comp`となっているファイルを書き換えたのち、`glslc`などのツールでSPIR-Vの中間コード(`.spv`ファイル)を作成すればよい。
## 説明
* C++において、Vulkanを用いて行列の和積をおこなうコード。`std::vector<std::vector<float>>`のような`float`型の動的二次元配列を想定している。
返り値の型も`std::vector<std::vector<float>>`である。
* (2024/11/16追記: 複素行列の行列積と和を追加。引数と返り値の型は`std::vector<std::vector<std::complex<float>>>`としている。)
* 行列の和と差に関しては、各スレッドごとに足している。
* 行列積に関しては、ローカルグループごとの共有メモリを用いている。共有メモリを用いた実装では、小行列を生成し、その中で和をとるというのを繰り返している。
* 共有メモリを使用せずに単純にスレッドごとに計算した場合と比べて、各スレッドごとのループ回数はワークグループのサイズ分ほど増えるが、共有メモリ内でのアクセスによる高速化のほうがメリットが大きいようである。
* 下の図は、`n×n`の2つの行列に対して、行列積を計算した際の計算時間である。行列のサイズが大きくなるにつれて、共有メモリを用いた実装の方が計算時間を短縮できていることがわかる。
   <p align = "center">
   <img src = "https://github.com/user-attachments/assets/197d3fe0-5b9b-49ea-85db-d5aad9a35a2e">
   </p>
* ちなみに、for文の三重ループによる、サイズが1000×1000の2つの行列の行列積の計算には、約66.24秒ほどかかった。
## 使い方
1. `.spv`ファイルと`matCalculation.cpp`と`matCalculation.h`を適切なフォルダにいれる。
`matCalculation.cpp`における`.spv`ファイルのパスをいじることになる可能性あり。
2.   `Matrix`クラスのインスタンスをつくる。
3. そのインスタンスが持つ関数の引数に、計算したい二次元配列や定数を入れる。
   1.  `multi`関数: 引数に入れた2つの行列の行列積を計算。
   2.  `multiEach`関数: 引数に入れた2つの行列の要素ごとの積を計算。
   3.  `sum`関数: 引数に入れた2つの変数の和を計算。行列同士か、行列と定数の組み合わせがとれる。
   4.  `diff`関数: 引数に入れた2つの変数の差を計算。`(1つ目の引数の行列) - (2つ目の行列の引数)`の順。
   5.  `complexMulti`関数: 引数に入れた2つの複素行列の行列積を計算。
   6.  `complexSum`関数: 引数に入れた2つの複素行列の和を計算。

